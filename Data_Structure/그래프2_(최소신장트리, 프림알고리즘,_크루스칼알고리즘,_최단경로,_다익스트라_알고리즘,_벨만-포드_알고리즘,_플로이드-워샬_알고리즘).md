#### ğŸ“š 1. ìµœì†Œì‹ ì¥íŠ¸ë¦¬
> ğŸ’¡ ì‹ ì¥íŠ¸ë¦¬(spanning tree)
* ê·¸ë˜í”„ì˜ ê°„ì„ ì„ 'ì •ì  ìˆ˜ - 1' ë§Œí¼ ë‚¨ê²¨ ë§Œë“  íŠ¸ë¦¬
* ex) ë„ˆë¹„ìš°ì„ íŠ¸ë¦¬, ê¹Šì´ìš°ì„ íŠ¸ë¦¬
> ğŸ’¡ ìµœì†Œ ì‹ ì¥íŠ¸ë¦¬(spanning tree)
* ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ í•©ì´ ê°€ì¥ ì‘ê²Œ ë˜ë„ë¡ ë§Œë“  ì‹ ì¥íŠ¸ë¦¬
* ex) ì—¬ëŸ¬ ê°€êµ¬ì— ì „ë ¥ì„ ê³µê¸‰í•˜ê¸° ìœ„í•œ ê³µê¸‰ë§ì˜ ì„¤ê³„

#### ğŸ“š 2. í”„ë¦¼ì•Œê³ ë¦¬ì¦˜
> ğŸ’¡ í”„ë¦¼ì•Œê³ ë¦¬ì¦˜
* 1. ìµœì†Œì‹ ì¥íŠ¸ë¦¬ì— í¬í•¨ëœ ì •ì ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ì§‘í•© Sìƒì„±
* 2. ì‹œì‘ ì •ì ì„ ì œì™¸í•œ ëª¨ë“  ì •ì ì— ì—°ê²°ë¹„ìš© ê°’ì„ ë¬´í•œëŒ€ë¡œ ì„¤ì •(ì‹œì‘ ì •ì ì€ 0ìœ¼ë¡œ)
* 3. ëª¨ë“  ì •ì ì´ ì§‘í•© Sì— í¬í•¨ë  ë•Œê¹Œì§€ ë°˜ë³µ
    * (1) Sì— í¬í•¨ë˜ì§€ ì•Šì€ ì •ì  ì¤‘ ìµœì†Œê°’ì„ ê°€ì§€ëŠ” ì •ì (u)ë¥¼ ì„ íƒí•˜ì—¬ Sì— ì¶”ê°€
    * (2) uì˜ ì´ì›ƒì— í•´ë‹¹í•˜ëŠ” ì •ì ë“¤ì˜ ì—°ê²°ë¹„ìš© ê°’ì„ ê°±ì‹  : uì˜ ì´ì›ƒ vì— ëŒ€í•´, ê°„ì„  (u,v)ì˜ ê°€ì¤‘ì¹˜ê°€ ê¸°ì¡´ vê°’ë³´ë‹¤ ì‘ìœ¼ë©´ vê°’ì„ ê°„ì„ (u,v)ì˜ ê°€ì¤‘ì¹˜ë¡œ ë³€ê²½    
![](https://velog.velcdn.com/images/codudals98/post/42d9ac08-21c7-4753-979d-08d885e571c7/image.png)![](https://velog.velcdn.com/images/codudals98/post/61487004-7fe5-4767-bf77-44e8790bf191/image.png)![](https://velog.velcdn.com/images/codudals98/post/995c318a-263b-46d4-bdbd-dcbb8b2f0e07/image.png)
####
> ğŸ’¡ í”„ë¦¼ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ë³µì¡ë„
* ëª¨ë“  ì •ì ì´ Sì— í¬í•¨ë  ë•Œê¹Œì§€ ë°˜ë³µ -> V
    * Sì— í¬í•¨ë˜ì§€ ì•Šì€ ì •ì  ì¤‘ ìµœì†Œê°’ì„ ê°€ì§€ëŠ” ì •ì (u)ë¥¼ ì„ íƒí•˜ì—¬ Sì— ì¶”ê°€ -> logV(í™ì •ë ¬ì„ ì‚¬ìš©í•  ê²½ìš° ìµœì†Œê°’ ì œê±° í›„ ìˆ˜ì„  ë¹„ìš©)
    * uì˜ ì´ì›ƒì— í•´ë‹¹í•˜ëŠ” ì •ì ë“¤ì˜ ì—°ê²°ë¹„ìš© ê°’ì„ ê°±ì‹ 
        * E x, uì˜ ì´ì›ƒ vì— ëŒ€í•´, ê°„ì„  (u,v)ì˜ ê°€ì¤‘ì¹˜ê°€ ê¸°ì¡´ vê°’ë³´ë‹¤ ì‘ìœ¼ë©´ vê°’ì„ ê°„ì„  (u,v)ì˜ ê°€ì¤‘ì¹˜ë¡œ ë³€ê²½ 
        * logV (í™ì—ì„œ ì›ì†Œê°’ì´ ë³€í–ˆì„ ë•Œ ìˆ˜ì„ ì— í•„ìš”í•œ ë¹„ìš©)             
* ì‹œê°„ ë³µì¡ë„: O(VlogV + ElovV) -> O(ElogV)
####
> ğŸ’¡ í”„ë¦¼ì•Œê³ ë¦¬ì¦˜ì˜ êµ¬í˜„
```py
def primMST(self):
>
	key = [sys.maxint] * self.V
	parent = [None] * self.V
>    
	key[0] = 0
>    
	mstSet = [False] * self.V
>    
	parent[0] = -1
>    
	for cout in range(self.V):
		u = self.minKey(key, mstSet)
		mstSet[u] = True
>        
		for v in range(self.V):
>        
			if self.graph[u][v] > 0 and mstSet[v] == False and \
			key[v] > self.graph[u][v]:
>            
				key[v] = self.graph[u][v]
				parent[v] = u
```
####

#### ğŸ“š 3. í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜
> ğŸ’¡ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜
* ê°„ì„ ë“¤ì„ ê°€ì¤‘ì¹˜ì˜ í¬ê¸° ìˆœìœ¼ë¡œ ì •ë ¬
* ì‹ ì¥íŠ¸ë¦¬ì— í¬í•¨ëœ ê°„ì„ ì˜ ìˆ˜ê°€ 'ì •ì  ìˆ˜ - 1'ì´ ë  ë•Œê¹Œì§€ ë°˜ë³µ
    * (1) : ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ì‘ì€ ê°„ì„  ì„ íƒ. 
    * (2) : í•´ë‹¹ ê°„ì„ ì´ ì‹¸ì´í´ì„ ë§Œë“¤ì–´ë‚´ë©´ í•´ë‹¹ ê°„ì„ ì„ íƒì‹œ íŠ¸ë¦¬ê°€ ì„±ë¦½í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ë²„ë¦¬ê³ , ë§Œë“¤ì§€ ì•ŠëŠ” ê°„ì„ ì´ë¼ë©´ ì‹ ì¥íŠ¸ë¦¬ì— í¬í•¨.     
![](https://velog.velcdn.com/images/codudals98/post/9dcb5807-5fea-4cd5-a3d8-ec5eb00c370f/image.png)![](https://velog.velcdn.com/images/codudals98/post/e6e8ec2b-951b-453a-b59b-585b953b105f/image.png)
####
> ğŸ’¡ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ë³µì¡ë„
* ê°„ì„ ë“¤ì„ ê°€ì¤‘ì¹˜ì˜ í¬ê¸° ìˆœìœ¼ë¡œ ì •ë ¬ -> O(ElogE)
* ì‹ ì¥íŠ¸ë¦¬ì— í¬í•¨ëœ ê°„ì„ ì˜ ìˆ˜ê°€ 'ì •ì  ìˆ˜ -1'ì´ ë  ë•Œê¹Œì§€ ë°˜ë³µí•¨
    * (1) : ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ì‘ì€ ê°„ì„ ì„ ì„ íƒ í›„
    * (2) : í•´ë‹¹ ê°„ì„ ì´ ì‹¸ì´í´ì„ ë§Œë“¤ì–´ë‚´ë©´ í•´ë‹¹ ê°„ì„  ì„ íƒì‹œ íŠ¸ë¦¬ê°€ ì„±ë¦½í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ë²„ë¦¼, ì‹¸ì´í´ì„ ë§Œë“¤ì–´ ë‚´ì§€ ì•ŠëŠ” ê°„ì„ ì´ë¼ë©´ ì‹ ì¥íŠ¸ë¦¬ì— í¬í•¨
* ì‹œê°„ ë³µì¡ë„: O(ElogE) -> O(ElogV)
####
> ğŸ’¡ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì˜ êµ¬í˜„
```py
def KruskalMST(self):
...
	# Step 1: Sort all the edges in non-decreasing order of their weight.
	self.graph = sorted(self.graph, key=lambda item: item[2])
>	
    # Number of edges to be taken is equal to V-1
	while e < self.V - 1:
		# Step 2: Pick the smallest edge
		u, v, w = self.graph[i]
		...
		# If including this edge does't cause cycle, include it in result
		# and increment the index of result for next edge
>
		if not is_cycle(u, v, result, self.graph):
			e = e + 1
			result.append([u, v, w])
		# Else discard the edge
```
####

#### ğŸ“š 4. ìµœë‹¨ ê²½ë¡œ
> ğŸ’¡ ìµœë‹¨ê²½ë¡œ ë¬¸ì œ
* ê²½ë¡œì˜ ê¸¸ì´ : ê²½ë¡œê°€ í¬í•¨í•˜ëŠ” ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ í•©
* ê·¸ë˜í”„ì˜ ì‹œì‘ ì •ì ì—ì„œ ë„ì°© ì •ì ê¹Œì§€ì˜ ìµœë‹¨ê²½ë¡œë¥¼ ì°¾ëŠ” ë¬¸ì œ
* ë„¤ë¹„ê²Œì´ì…˜, ë¬¼ë¥˜, ê³µì¥ì˜ ë¶€í’ˆ ì´ë™ ìµœì í™” ë“±ì˜ ë¬¸ì œì— ì ìš©

#### ğŸ“š 5. ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜
> ğŸ’¡ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜
* ì‹œì‘ ì •ì ìœ¼ë¡œë¶€í„° ëª¨ë“  ë‹¤ë¥¸ ì •ì¦˜ìœ¼ë¡œì˜ ìµœë‹¨ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
* ìŒì˜ ê°€ì¤‘ì¹˜ê°€ ì—†ëŠ” ê²½ìš°ì—ë§Œ ì„±ë¦½
* í”„ë¦¼ì•Œê³ ë¦¬ì¦˜ê³¼ ìœ ì‚¬
    * í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì€ ê° ì •ì ì˜ ê°’ì´ ì‹ ì¥íŠ¸ë¦¬ì— ì—°ê²°í•˜ëŠ” ìµœì†Œë¹„ìš©ì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ ì‚¬ìš©ë˜ì§€ë§Œ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì€ ìµœë‹¨ê±°ë¦¬ë¥¼ íŒë‹¨í•˜ê¸° ìœ„í•´ ì‚¬ìš©    
####
> ğŸ’¡ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ ë™ì‘ ë°©ì‹
* 1. ìµœë‹¨ê²½ë¡œì˜ ê³„ì‚°ì´ ëë‚œ ì •ì €ë“¤ì˜ ì§‘í•© Së¥¼ ìƒì„±
* 2. ì‹œì‘ ì •ì ì„ ì œì™¸í•œ ëª¨ë“  ì •ì ì˜ ê±°ë¦¬ ê°’ì„ ë¬´í•œëŒ€ë¡œ ì €ì¥ (ì‹œì‘ ì •ì ì€ 0ìœ¼ë¡œ)
* 3. ëª¨ë“  ì •ì ì´ ì§‘í•© Sì— í¬í•¨ë  ë•Œê¹Œì§€ ë°˜ë³µ
    * (1). Sì— í¬í•¨ë˜ì§€ ì•Šì€ ì •ì  ì¤‘ ìµœì†Œê°’ì„ ê°€ì§€ëŠ” ì •ì (u)ì„ ì„ íƒí•˜ì—¬ Sì— ì¶”ê°€
    * (2). uì˜ ì´ì›ƒì— í•´ë‹¹í•˜ëŠ” ì •ì ë“¤ì˜ ê±°ë¦¬ê°’ì„ ê°±ì‹ : uì˜ ì´ì›ƒ vì— ëŒ€í•´, 'ê°„ì„  (u, v)ì˜ ê°€ì¤‘ì¹˜ + u ê°’'ì´ ê¸°ì¡´ v ê°’ë³´ë‹¤ ì‘ìœ¼ë©´ v ê°’ì„'ê°„ì„  (u, v)ì˜ ê°€ì¤‘ì¹˜ + u ê°’'ìœ¼ë¡œ ë³€ê²½
![](https://velog.velcdn.com/images/codudals98/post/dfd55b03-d3de-4d50-a3aa-ebb510702dad/image.png)![](https://velog.velcdn.com/images/codudals98/post/37fc5e0d-acd5-48c1-86ac-b19cd1cb7fa3/image.png)
####
> ğŸ’¡ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ë³µì¡ë„    
* í”„ë¦¼ì•Œê³ ë¦¬ì¦˜ê³¼ êµ¬ì¡°ê°€ ì™„ì „íˆ ê°™ìœ¼ë¯€ë¡œ O(ElogV)
####
> ğŸ’¡ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì˜ êµ¬í˜„
```py
def dijkstra(self, src):
>
	dist = [sys.maxint] * self.V
	dist[src] = 0
>    
	sptSet = [False] * self.V
>    
	for cout in range(self.V):
		x = self.minDistance(dist, sptSet)
		sptSet[x] = True
>        
	# Update dist value of the adjacent vertices
	# of the picked vertex only if the current
	# distance is greater than new distance and
	# the vertex in not in the shortest path tree
>    
	for y in range(self.V):
>    
		if self.graph[x][y] > 0 and sptSet[y] == False and \
		dist[y] > dist[x] + self.graph[x][y]:
			dist[y] = dist[x] + self.graph[x][y]
```
####

#### ğŸ“š 6. ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜
> ğŸ’¡ ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜
* ì‹œì‘ ì •ì¦˜ìœ¼ë¡œë¶€í„° ëª¨ë“  ë‹¤ë¥¸ ì •ì ìœ¼ë¡œì˜ ìµœë‹¨ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
* ìŒì˜ ê°€ì¤‘ì¹˜ê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°ì—ë„ ì„±ë¦½ (ìŒì˜ ì‹¸ì´í´ì€ í—ˆìš©ë˜ì§€ ì•ŠìŒ)
####
> ğŸ’¡ ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ ë™ì‘ ë°©ì‹
* 1. ì‹œì‘ ì •ì ì„ ì œì™¸í•œ ëª¨ë“  ì •ì ì˜ ê±°ë¦¬ ê°’ì„ ë¬´í•œëŒ€ë¡œ ì €ì¥ (ì‹œì‘ ì •ì ì€ 0ìœ¼ë¡œ)
* 2. ë‹¤ìŒ ë‹¨ê³„ë¥¼'ì •ì  ìˆ˜(|ğ‘‰|) - 1'ë§Œí¼ ë°˜ë³µ
    * (1) ì´ì „ ë‹¨ê³„ì—ì„œ ê±°ë¦¬ ê°’ì´ ê°±ì‹ ëœ ì •ì ë“¤(u)ì˜ ì´ì›ƒ(v)ì„ êµ¬í•œ ë’¤, ì´ì›ƒë“¤ì˜ ê±°ë¦¬ ê°’ì„ ê°±ì‹ : 
'ê°„ì„  (u, v)ì˜ ê°€ì¤‘ì¹˜ + u ê°’'ì´ ê¸°ì¡´ v ê°’ë³´ë‹¤ ì‘ìœ¼ë©´ v ê°’ì„ 'ê°„ì„  (u, v)ì˜ ê°€ì¤‘ì¹˜ + u ê°’'ìœ¼ë¡œ ë³€ê²½
* 3. ë§ˆì§€ë§‰ì— ì •ì ì˜ ê±°ë¦¬ ê°’ì„ ê°±ì‹ í•˜ëŠ”ë° ì‚¬ìš©ëœ ê°„ì„ ë“¤ì´ ìµœë‹¨ê²½ë¡œê°€ ë¨
![](https://velog.velcdn.com/images/codudals98/post/6579af79-6ddc-47c5-9b2e-1abdff75490d/image.png)![](https://velog.velcdn.com/images/codudals98/post/ebcffc0c-e6f2-4671-b54a-b6fcdc9ab615/image.png)
####
> ğŸ’¡ ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ë³µì¡ë„    
* ì‹œì‘ ì •ì ì„ ì œì™¸í•œ ëª¨ë“  ì •ì ì˜ ê±°ë¦¬ ê°’ì„ ë¬´í•œëŒ€ë¡œ ì €ì¥ (ì‹œì‘ ì •ì ì€ 0ìœ¼ë¡œ) -> ìƒìˆ˜ ì‹œê°„
* ë‹¤ìŒ ë‹¨ê³„ë¥¼ ì •ì¤Œìˆ˜(|V|) - 1ë§Œí¼ ë°˜ë³µ -> V X 
    * ì´ì „ ë‹¨ê³„ì—ì„œ ê±°ë¦¬ ê°’ì´ ê°±ì‹ ëœ ì •ì ë“¤(u)ì˜ ì´ì›ƒ(v)ì„ êµ¬í•œ ë’¤,ì´ì›ƒë“¤ì˜ ê±°ë¦¬ ê°’ì„ ê°±ì‹ : â†’ ğ¸ Ã—
'ê°„ì„  (u, v)ì˜ ê°€ì¤‘ì¹˜ + u ê°’'ì´ ê¸°ì¡´ v ê°’ë³´ë‹¤ ì‘ìœ¼ë©´ v ê°’ì„'ê°„ì„  (u, v)ì˜ ê°€ì¤‘ì¹˜ + u ê°’'ìœ¼ë¡œ ë³€ê²½ â†’ ìƒìˆ˜ ì‹œê°„
* ì‹œê°„ë³µì¡ë„ : O(VE)
####
> ğŸ’¡ ë²¨ë§Œ-í¬ë“œ ì•Œê³ ë¦¬ì¦˜ì˜ êµ¬í˜„
```py
def BellmanFord(self, src):
	# Step 1: Initialize distances from src to all other vertices as INFINITE
>    
	dist = [float("Inf")] * self.V
	dist[src] = 0
>
	# Step 2: Relax all edges |V| - 1 times. A simple shortest
	# path from src to any other vertex can have at-most |V| - 1 edges
>	
    for _ in range(self.V - 1):
		# Update dist value and parent index of the adjacent vertices of
		# the picked vertex. Consider only those vertices which are still in queue
>        
		for u, v, w in self.graph:
>        
			if dist[u] != float("Inf") and dist[u] + w < dist[v]: 
            	dist[v] = dist[u] + w
```
####

#### ğŸ“š 7. í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜
> ğŸ’¡ í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜
* ëª¨ë“  ì •ì  ìŒ ì‚¬ì´ì˜ ìµœë‹¨ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
####
> ğŸ’¡ í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
```py
for i in vertices:
	for j in vertices:
		dist[i][j] = weight[i][j]
>
for k in vertices:
	for i in vertices:
		for j in vertices:
			if dist[i][k] + dist[k][j] < dist[i][j]:
				dist[i][j] = dist[i][k] + dist[k][j]
```
####
> ğŸ’¡ í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ë³µì¡ë„
* í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ë³µì¡ë„ : O(V^3)